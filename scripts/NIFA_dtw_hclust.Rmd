---
title: 'NIFA - dynamic time warping and hierarchical clustering'
author: "Cassandra Wattenburger"
date: "3/8/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(results = "show")
knitr::opts_chunk$set(message = FALSE)
```

```{r}
# Clear working directory, load in packages, generate package info
rm(list=ls())

library("tidyverse")

sessionInfo()
```

# Import, prep data

```{r}
# Normalized abundances
ts_abund <- readRDS("../data_intermediate/NIFA_norm_prepped.rds")

# Growth estimates
growth <- readRDS("../data_intermediate/NIFA_grests_final_ind.rds")
# Growing taxa labels
growth_labs <- growth %>% 
  select(label) %>% 
  unique()

# Reformat
# Remove no-growth time series
ts_abund_gr <- ts_abund %>% 
  semi_join(growth_labs)

# Series numbers
ts_nums <- ts_abund_gr %>%
  select(label) %>%
  unique() %>% 
  add_column(ts = 1:nrow(.))

# Clean up
ts_abund_gr <- left_join(ts_abund_gr, ts_nums) %>% 
  select(ts, label, day=Day, abund=norm_abund)


# TROUBLESHOOTING
ts_abund_gr %>% 
  group_by(ts) %>% 
  summarize(days = n()) %>% 
  ungroup() 
```

Visualize:

Raw time series

```{r}
# Randomly select 50 time series for preprocessing comparisons
set.seed(50)
rand_ts <- sample(unique(ts_abund_gr$ts), 20)
```

```{r}
# All
ts_abund_gr %>% 
  ggplot(aes(x=day, y=abund)) +
  geom_line(aes(group=ts), alpha=0.2) +
  labs(title="All") +
  theme_test()

# random 50
ts_abund_gr %>% 
  filter(ts %in% rand_ts) %>% 
  ggplot(aes(x=day, y=abund)) +
  geom_line(aes(group=ts, color=label)) +
  labs(title="50 random") +
  theme_test() +
  theme(legend.position = "none")
```

# Preprocessing

## ln transform

This is how bacterial growth data is typically viewed and interpretted due to exponential growth characteristic.

Decreases impact of differences in starting or ending abundances on dissimilarity.

```{r}
ts_abund_gr <- ts_abund_gr %>% 
  mutate(abund_ln = log(abund))
```

Visualize:

```{r}
# All
ts_abund_gr %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_line(aes(group=ts), alpha=0.2) +
  labs(title="All") +
  theme_test()

# random 50
ts_abund_gr %>% 
  filter(ts %in% rand_ts) %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_line(aes(group=ts, color=label)) +
  labs(title="50 random") +
  theme_test() +
  theme(legend.position = "none")
```

## Min/max normalize

x_norm = (x - min)/(max - min)

Forces time series between 0 and 1 so that all time series are within comparable range.

```{r}
# Mins and maxes of each time series
ts_minmax <- ts_abund_gr %>% 
  group_by(label) %>% 
  summarize(ts_min = min(abund_ln),
            ts_max = max(abund_ln))

# Normalize
# y = (x - min) / (max - min)
ts_abund_gr <- ts_abund_gr %>% 
  left_join(ts_minmax, by="label") %>%
  mutate(abund_norm = (abund_ln - ts_min)/(ts_max - ts_min)) %>% 
  select(ts, label, day, abund, abund_ln, abund_norm)
```

Visualize:

```{r}
# All
ts_abund_gr %>% 
  ggplot(aes(x=day, y=abund_norm)) +
  geom_line(aes(group=ts), alpha=0.2) +
  labs(title="All") +
  theme_test()

# random 50
ts_abund_gr %>% 
  filter(ts %in% rand_ts) %>% 
  ggplot(aes(x=day, y=abund_norm)) +
  geom_line(aes(group=ts, color=label)) +
  labs(title="50 random") +
  theme_test() +
  theme(legend.position = "none")
```

## Reformat to list

DTW function with parallelization likes this format.

```{r}
# Wide format
ts_abund_wide <- ts_abund_gr %>% 
  select(ts, label, day, abund_norm) %>% 
  pivot_wider(names_from=day, values_from=abund_norm)

# Create named list of time series
ts_abund_list <- list()
labels <- as.character(ts_abund_wide$label)
for (i in 1:nrow(ts_abund_wide)) {
  ts <- ts_abund_wide[i, 3:ncol(ts_abund_wide)] %>% 
    as.numeric() %>% 
    na.omit() %>% 
    as.numeric()
  temp_list <- lst(ts)
  ts_abund_list <- c(ts_abund_list, temp_list)
}
names(ts_abund_list) <- labels
```

# DTW

Set up multithreading for dtwclust():

https://cran.r-project.org/web/packages/dtwclust/vignettes/parallelization-considerations.html

```{r}
# Set up multithreading with most of the server's processors (80 of 96)
## Restart R to change number of threads
library("parallel")
library("doParallel")

workers <- makeCluster(48)

invisible(clusterEvalQ(workers, {
    library(dtwclust)
    RcppParallel::setThreadOptions(1L)
}))

require(doParallel)
registerDoParallel(workers)
```

All pairwise comparisons:

Using defaults, cannot place lowerbounds due to differing time series lengths.

```{r}
library("dtwclust")

dtw_dist <- proxy::dist(ts_abund_list, method = "dtw_basic")
```

# Principle components

```{r}
dtw_pc <- prcomp(dtw_dist)
head(summary(dtw_pc)$importance[3,])
plot(summary(dtw_pc)$importance[3,])
```

First two components describe 65% of variation, not bad.

Visualize:

```{r}
dtw_pc_df <- dtw_pc$x %>% 
  as.data.frame() %>% 
  rownames_to_column(var="label")

dtw_pc_df %>% 
  ggplot(aes(x=PC1, y=PC2)) +
  geom_point() + 
  theme_test()
```

# Hierarchical clustering

Agglomerative:

```{r}
library("factoextra")
library("cluster")

# Single, complete, and average
agnes_sing <- agnes(dtw_dist, metric="euclidean", method = "single")
agnes_compl <- agnes(dtw_dist, metric="euclidean", method = "complete")
agnes_avg <- agnes(dtw_dist, metric="euclidean", method = "average")

agnes_sing$ac
agnes_compl$ac
agnes_avg$ac
```

Complete linkage provides the best agglomerative coefficient.

Devisive:

```{r}
diana_euc <- diana(dtw_dist)
diana_euc$dc
```

Agglomerative hierarchical clustering with complete linkage seems to give best cluster cohesion.

# Cluster number

Scree and height gap plots:

Graphing functions: https://tomytjandra.github.io/blogs/r/time-series/clustering/2020/11/04/time-series-hierarchical-clustering.html#Determine-optimal-clusters

```{r}
# Function
scree_plot_hc <- function(hc, which.plots = 1) {
  df <-
    data.frame(k = 1:length(hc$height),
               h = rev(sort(hc$height))) %>% 
    mutate(gap = abs(h - lag(h)))
  
  if (which.plots == 1) {
    
    p <- ggplot(df, aes(x = k, y = h)) +
      geom_line(color = 'blue') +
      geom_point(size = 0.75) +
      labs(x = "Number of clusters k",
           y = "Height",
           title = "Scree Plot") +
      theme_classic()
    
    print(p)
    
  } else if (which.plots == 2) {
    
    df %>% 
      arrange(desc(gap)) %>% 
      top_n(10) %>% 
      ggplot(aes(x = reorder(k, -gap), y = gap)) +
      geom_col() +
      labs(x = "Number of clusters k",
           y = "Height Gap",
           title = "Largest Gap Method") +
      theme_classic()
    
  }
}
```

```{r}
scree_plot_hc(agnes_compl, which.plots = 1)
scree_plot_hc(agnes_compl, which.plots = 2)
```

There is a clear elbow but there are way too many clusters. Height gap plot seems to indicate that 4 clusters is ideal, and that is reflected in the scree plot as well.

Silohuettes:

Describes similarity to observation to its own cluster. Positive silhouette width is more similar, negative is less similar.

```{r}
# 4 clusterss
hc_4 <- cutree(agnes_compl, k = 4)
sil_4 <- silhouette(hc_4, dtw_dist)
plot(sil_4, col=1:4, main="4 clusters")
sil_4_df <- data.frame(sil_4)

# Average silohuette
sil_4_df %>% 
  summarize(mean(sil_width))

sil_4_df %>% 
  mutate(cluster = as.factor(cluster)) %>% 
  ggplot(aes(x=sil_width, y=cluster, color=cluster)) +
  geom_jitter() +
  geom_vline(xintercept = 0, linetype = 2) +
  theme_test()
```

Average silohuette width is very close to 0, must be lots of overlap between clusters?

# Visualize clusters

PC1 and PC2 with cluster color-coding:

```{r}
final_cluster4 <- cutree(as.hclust(agnes_compl), k = 4)
table(final_cluster4)

cluster_mapping4 <- rownames_to_column(as.data.frame(final_cluster4),
                     var = "label") %>% 
  rename(cluster = final_cluster4) %>% 
  mutate(cluster = as.factor(cluster))

dtw_pc_df %>% 
  left_join(cluster_mapping4) %>% 
  ggplot(aes(x=PC1, y=PC2, color=cluster)) +
  geom_point() + 
  theme_test()

# How many observations in each cluster?
dtw_pc_df %>% 
  left_join(cluster_mapping4) %>% 
  group_by(cluster) %>% 
  summarize(total=n())
```

That doesn't seem bad to me! Cluster 4 is a bit interesting because overlaps with clusters 1 and 2. Must be outliers in some way?

Dendrogram:

```{r}
library("dendextend")
dend_viz <- color_branches(as.hclust(agnes_compl), k = 4)
plot(dend_viz, main="4 clusters", xaxt="n")
```

# Barycenters

"A matrix or data frame where each row is a time series, or a list where each element is a time series. Multivariate series should be provided as a list of matrices where time spans the rows and the variables span the columns of each matrix."

```{r}
# Add cluster mapping info
ts_abund_dba <- ts_abund_wide %>% 
  left_join(cluster_mapping4) %>% 
  select(everything(), -ts, -label)

# Convert to lists
for (c in c(1, 2, 3, 4)) { # each cluster
  ts_abund_sub <- filter(ts_abund_dba, cluster==c) %>% 
    select(-cluster)
  x <- list()
   # create object for cluster
  for (i in 1:nrow(ts_abund_sub)) { # each time series
    ts <- ts_abund_sub[i,] %>% 
      as.numeric() %>% 
      na.omit() %>% 
      as.numeric()
    temp_list <- lst(ts)
    x <- c(x, temp_list)
  }
  assign(paste0("ts_abund_dba", c), x)
}

# Calculate barycenter for each cluster
barycenter1 <- DBA(ts_abund_dba1)
barycenter2 <- DBA(ts_abund_dba2)
barycenter3 <- DBA(ts_abund_dba3)
barycenter4 <- DBA(ts_abund_dba4)

# Reformat barycenters into dataframe
barycenter1_df <- data.frame(c(barycenter1, rep(NA, 30-length(barycenter1)))) %>% 
  rename(cluster1="c.barycenter1..rep.NA..30...length.barycenter1...")
barycenter2_df <- data.frame(c(barycenter2, rep(NA, 30-length(barycenter2)))) %>% 
  rename(cluster2="c.barycenter2..rep.NA..30...length.barycenter2...")
barycenter3_df <- data.frame(c(barycenter3, rep(NA, 30-length(barycenter3)))) %>% 
  rename(cluster3="c.barycenter3..rep.NA..30...length.barycenter3...")
barycenter4_df <- data.frame(c(barycenter4, rep(NA, 30-length(barycenter4)))) %>% 
  rename(cluster4="c.barycenter4..rep.NA..30...length.barycenter4...")

barycenters_df <- bind_cols(barycenter1_df, barycenter2_df) %>% 
  bind_cols(barycenter3_df) %>% 
  bind_cols(barycenter4_df) %>% 
  rownames_to_column(var="tp") %>% 
  pivot_longer(-tp, names_to="cluster", values_to="abund_norm") %>% 
  mutate(cluster = as_factor(cluster),
         tp = as.numeric(tp))
```

Visualize:

```{r}
barycenters_df %>% 
  ggplot(aes(x=tp, y=abund_norm, color=cluster)) + 
  geom_point(size=2) +
  geom_line(size=0.5) +
  geom_smooth(method="loess", se=F, linetype=2) +
  theme_test()
```

Cluster 2 is weird. Why so short?

# Exploration

Construct dataframe with clustered time series information.

```{r}
# Import paprica estimates and taxonomy
pap <- readRDS("../data_intermediate/NIFA_paprica_ests.rds")
tax <- read_tsv("../data_amplicon/NIFA2/final/NIFA2.taxonomy-final.tsv")

# Time series data
abund_clust <- ts_abund_gr %>% 
  left_join(cluster_mapping4) %>% 
  mutate(Soil=if_else(grepl("Ag", label), "Ag", "Meadow"),
         Replicate=gsub("[a-z]+([1-3])_(.+)", "\\1", label, ignore.case=TRUE),
         ASV=gsub("[a-z]+([1-3])_(.+)", "\\2", label, ignore.case=TRUE)) %>% 
  select(label, Soil, Replicate, ASV, ts, day, cluster, abund:abund_norm) %>% 
  left_join(pap) %>% 
  left_join(tax)
  
# Growth estimates
growth_clust <- growth %>% 
  left_join(pap) %>% 
  left_join(tax) %>% 
  left_join(cluster_mapping4)
```

## Time series by cluster

```{r}
# Cluster 1
abund_clust %>% 
  filter(cluster==1) %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_point(alpha=0.5) +
  geom_line(aes(group=label), alpha=0.5) +
  labs(title="Cluster 1 time series") +
  theme_test()

# Cluster 2
abund_clust %>% 
  filter(cluster==2) %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_point(alpha=0.5) +
  geom_line(aes(group=label), alpha=0.5) +
  labs(title="Cluster 2 time series") +
  theme_test()

# Cluster 3
abund_clust %>% 
  filter(cluster==3) %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_point(alpha=0.5) +
  geom_line(aes(group=label), alpha=0.5) +
  labs(title="Cluster 3 time series") +
  theme_test()

# Cluster 4
abund_clust %>% 
  filter(cluster==4) %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_point(alpha=0.5) +
  geom_line(aes(group=label), alpha=0.5) +
  labs(title="Cluster 4 time series") +
  theme_test()
```

Randomly draw 25 from each cluster:

```{r}
rand10 <- cluster_mapping4 %>% 
  group_by(cluster) %>% 
  slice_sample(n=10)

# Cluster 1
abund_clust %>% 
  filter(cluster==1) %>% 
  semi_join(rand10) %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_point(alpha=0.5) +
  geom_line(aes(group=label), alpha=0.5) +
  labs(title="Cluster 1 time series") +
  theme_test()

# Cluster 2
abund_clust %>% 
  filter(cluster==2) %>% 
  semi_join(rand10) %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_point(alpha=0.5) +
  geom_line(aes(group=label), alpha=0.5) +
  labs(title="Cluster 2 time series") +
  theme_test()

# Cluster 3
abund_clust %>% 
  filter(cluster==3) %>% 
  semi_join(rand10) %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_point(alpha=0.5) +
  geom_line(aes(group=label), alpha=0.5) +
  labs(title="Cluster 3 time series") +
  theme_test()

# Cluster 4
abund_clust %>% 
  filter(cluster==4) %>% 
  semi_join(rand10) %>% 
  ggplot(aes(x=day, y=abund_ln)) +
  geom_point(alpha=0.5) +
  geom_line(aes(group=label), alpha=0.5) +
  labs(title="Cluster 4 time series") +
  theme_test()


```

## ASVs by cluster

Do ASVs present in multiple replicates ussually occur in the same cluster, or different cluster?

I would expect them to be more likely in the same cluster, if growth dynamics are governed by deterministic, trait-based factors. Stochasticity between replicates makes this difficult to assess.

# BOOKMARK
```{r}
asv_occ <- growth_clust %>% 
  group_by(ASV, Soil) %>% 
  summarize(occurence=n())

clust_occ <- cluster_mapping4 %>% 
  mutate(ASV=gsub("[a-z]+([1-3])_(.+)", "\\2", label, ignore.case=TRUE),
         Soil=if_else(grepl("Ag", label), "Ag", "Meadow")) %>% 
  left_join(asv_occ) %>% 
  select(label, ASV, Soil, cluster, occurence)

clust_occ %>% 
  filter()
```

## Cluster phylogenetic signal

Taxonomy-based.

## Growth metrics by cluster

k, lag, change abundance, 16S copy num., genome size

## Soils by cluster

Are clusters more frequent in one soil over another?


