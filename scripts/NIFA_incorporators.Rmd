---
title: "NIFA FullCyc2 incorporators workup"
author: "Cassandra Wattenburger"
date: "3/15/2023"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(results = "show")
knitr::opts_chunk$set(message = FALSE)
```

```{r}
# Clear working directory, load in packages, generate package info
rm(list=ls())

library("tidyverse")

sessionInfo()
```

# Import data

```{r}
# Incorporator data from DulLC
incorp <- readRDS("../cluster_fullcyc2/fullcyc2_l2fc_testoutput.rds")
incorp

# Taxonomy of incorporators
incorp_tax <- incorp %>% select(OTU, Phylum:Species)
```

# Reformat data

```{r}
# Reformat and exclude non-significant results
incorp_sig <- incorp %>% 
  mutate(ecosystem = gsub(".substrate == '12C-Con' & day == '[0-9]+' & ecosystem == '([a-z]+)'.+", "\\1", .id), # separate out .id column
         day = gsub(".substrate == '12C-Con' & day == '([0-9]+)' .+", "\\1", .id),
         day = as.numeric(day),
         substrate = gsub(".+substrate == '13C-([a-z]+)'.+", "\\1", .id, ignore.case=T),
         substrate = case_when(substrate=="Pal" ~ "palmitic acid",
                               substrate=="Ami" ~ "amino acid",
                               substrate=="Xyl" ~ "xylose",
                               substrate=="Cel" ~ "cellulose",
                               substrate=="Van" ~ "vanillin")) %>%
  select(OTU, ecosystem, day, substrate, log2FoldChange, padj) %>% 
  filter(padj < 0.05) # filter incorporators, Sam says deseq2 was set up so negative log2foldchange indicates incorporation
  
incorp_sig
```

Create list of incorporator OTUs:

```{r}
incorp_otus <- select(incorp_sig, OTU) %>% 
  unique()
```

```{r, eval=FALSE}
write_tsv(incorp_otus, "../mothur_cluster/incorp_otus.txt")
```

Create list of growing taxa from NIFA experiment:

```{r}
growth_asvs <- readRDS("../data_intermediate/NIFA_grests_final_ind.rds") %>% 
  select(ASV) %>% 
  unique()
```

```{r, eval=FALSE}
write_tsv(growth_asvs, "../mothur_cluster/growth_asvs.txt")
```

# BLAST processing

Import: 

```{r}
blast <- read_tsv("../blast_fullcyc2/nifa_fullcyc2_blastn_parsed.txt")
head(blast)
```

Choose best hit for each ASV (with at least 97% identity):

```{r}
# Select best hit(s)
blast_best <- filter(blast, Identity >= 97) %>% # remove hits lower than 97% identity
  group_by(Query) %>% 
  summarize(Identity = max(Identity)) %>% # choose highest identity match
  ungroup()

blast_best <- semi_join(blast, blast_best)
blast_best

# Tidy up
blast_best <- select(blast_best, ASV=Query, blast_OTU=Hit, blast_identity=Identity, blast_evalue=Evalue)
  
# Some summary
length(unique(blast_best$Query)) # ASVs matched with at least 97% identity
min(blast_best$Identity) # lowest identity match in queries
```

Identify ties:

```{r}
# Isolate ASVs with multiple highest hits
blast_dups_logic <- duplicated(blast_best$ASV)

blast_dups_asvs <- blast_best %>% 
  add_column(duplicated = blast_dups_logic) %>% 
  filter(duplicated==TRUE) %>% 
  select(ASV) %>% 
  unique() %>% 
  as.list()

# How many ASVs with duplicate equally best hits?
length(blast_dups_asvs$ASV)

# Isolate duplicate hits
blast_dups <- blast_best %>% 
  filter(ASV %in% blast_dups_asvs$ASV)

# Isolate single hits
blast_sing <- blast_best %>% 
  filter(!(ASV %in% blast_dups_asvs$ASV))
```

## Deal with duplicate hits

For ASVs with two or more OTU hits with equal percentage identity, I'll choose the lowest e-value. If e values also tie, I'll keep the OTU properties of both (or all) OTU hits.

https://www.ncbi.nlm.nih.gov/books/NBK62051/

```{r}
blast_dups_eval <- blast_dups %>% 
  group_by(ASV) %>% 
  summarize(blast_evalue = min(blast_evalue)) %>% # isolate lowest e-value hit
  ungroup()

# Filter by min. e-value
blast_dups <- blast_dups %>% 
  semi_join(blast_dups_eval)

# Remaining duplicates
blast_dups_logic2 <- duplicated(blast_dups$ASV)
blast_dups_asvs2 <- blast_dups %>% 
  add_column(duplicated = blast_dups_logic2) %>% 
  filter(duplicated==TRUE) %>% 
  select(ASV) %>% 
  unique() %>% 
  as.list()

blast_dups2 <- filter(blast_dups, ASV %in% blast_dups_asvs2$ASV)
blast_dups2
```

Look at taxonomy of duplicate OTU hits

Are they closely related?

```{r}
# Isolate OTU hits from taxonomy info
tax_dups <- filter(incorp_tax, OTU %in% unique(blast_dups2$blast_OTU)) %>% 
  unique()

# Merge with blast results
blast_dups2 <- blast_dups2 %>% 
  left_join(tax_dups, by=join_by(blast_OTU==OTU))

blast_dups2
```

Visualize:

```{r}
# Phylum level
blast_dups2 %>% 
  ggplot(aes(x=Phylum, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Class
blast_dups2 %>% 
  ggplot(aes(x=Class, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Order
blast_dups2 %>% 
  ggplot(aes(x=Order, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Family
blast_dups2 %>% 
  ggplot(aes(x=Family, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Genus
blast_dups2 %>% 
  ggplot(aes(x=Genus, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Species
blast_dups2 %>% 
  ggplot(aes(x=Species, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())
```

These plots tell me if the duplicate OTU hits fall in the same or different taxonomic groups. One dot per graph means they all are within the same group.

Duplicate OTU hits start diverging ~ order level, but the splits are among "uncultured", "ambigious", or "NA" groups which tells me these are uncultured and uncharacterized which would explain variation in higher resolution taxonomic placement. Overall taxa are very closely related, as expected. Likely OK to merge the substrate use qualities for the ASVs

Combine single and duplicate blast results:

```{r}
# Put single hits back in with duplicate hits
blast_mh <- bind_rows(blast_sing, blast_dups) %>% 
  mutate(multiple_hit=if_else(ASV %in% blast_dups_asvs2$ASV, "yes", "no")) # Add multiple hit warning column

blast_mh
```

## Add incorp. info to BLAST results

```{r}
# Reformat incorporator data
incorp_sig <- incorp_sig %>% 
  mutate(label=paste0(OTU, ecosystem, day)) # create id column

incorp_meta <- select(incorp_sig, label, OTU, ecosystem, day) %>% 
  unique()

incorp_long <- incorp_sig %>% 
  add_column(incorporator = "yes") %>% 
  select(label, OTU, ecosystem, day, substrate, incorporator) %>% 
  pivot_wider(id_cols=label, names_from=substrate, values_from=incorporator) %>% 
  mutate_all(~ if_else(is.na(.x), "no", .x))

incorp_final <- full_join(incorp_long, incorp_meta, by=join_by(label)) %>% 
  select(label, OTU, ecosystem, day, palmitic_acid=`palmitic acid`, amino_acid=`amino acid`, xylose, cellulose, vanillin)

incorp_final
```


```{r}
# Join BLAST results with incorporation data
blast_incorp <- full_join(incorp_final, blast_mh, by=join_by(OTU==blast_OTU)) %>% 
  filter(!is.na(ASV)) %>% 
  rename(blast_OTU=OTU, incorp_label=label, incorp_day=day, incorp_eco=ecosystem) %>% 
  select(ASV, blast_OTU, blast_identity, blast_evalue, multiple_hit, incorp_label, incorp_eco, incorp_day, palmitic_acid:vanillin) %>% 
  arrange(ASV)

# Reformat
blast_incorp <- blast_incorp %>% 
  pivot_longer(cols=c(palmitic_acid:vanillin), names_to="substrate", values_to="incorporator")

blast_incorp
```

## Simplify

Create union of substrate incorporation properties among different ecosystems for the same OTU, was the OTU labelled and if so, what was the earliest day it was labelled in any ecosystem?

```{r}
blast_incorp_earliest <- data_frame()
for (a in unique(blast_incorp$ASV)) {
  data_a <- filter(blast_incorp, ASV==a & incorporator=="yes") # isolate substrates that a incorporated
  data_earliest <- data_a %>% 
    group_by(blast_OTU, substrate) %>% # for each substrate and OTU hit per ASV...
    summarize(incorp_earliest_day = min(incorp_day)) %>% # which was the earliest day of uptake?
    add_column(ASV=a)
  blast_incorp_earliest <- bind_rows(blast_incorp_earliest, data_earliest)
}

blast_incorp_earliest
```

```{r}
# Reformat data frame
blast_incorp2 <- blast_incorp %>% 
  left_join(blast_incorp_earliest) %>% # combine with earliest day of incorporation data
  filter(incorporator=="yes") %>%  # remove non-incorporators
  select(ASV:multiple_hit, substrate, incorp_earliest_day) %>% 
  filter(!is.na(incorp_earliest_day)) # remove rows with substrates that weren't incorporated

blast_incorp2
```

# Summarize incorporator hits to ASVs

BLAST % identity:

```{r}
asv_identity <- blast_incorp %>% 
  group_by(ASV) %>% 
  summarize(identity=mean(blast_identity)) %>% 
  ungroup()
  
mean(asv_identity$identity)
median(asv_identity$identity)
min(asv_identity$identity)
max(asv_identity$identity)
hist(asv_identity$identity, main="Histogram", xlab="Percent identity to nearest BLAST hit")
```

BLAST e-values:

```{r}
asv_evalue <- blast_incorp %>% 
  group_by(ASV) %>% 
  summarize(evalue=mean(blast_evalue)) %>% 
  ungroup()
  
mean(asv_evalue$evalue)
median(asv_evalue$evalue)
min(asv_evalue$evalue)
max(asv_evalue$evalue)
```

Number of incorporation hits per substrate:

```{r}
# Summary table
blast_incorp %>% 
  select(blast_OTU, incorp_earliest_day, substrate, incorporator) %>% 
  unique() %>% # remove duplicates created by blast ties to asvs
  # Add up the blast hit incorporators for each substrate (rethink this through sometime to double check math)
  group_by(substrate) %>% # count number of incorporating taxa per substrate
  summarize(total=n()) %>% 
  ungroup()

# Visualize
blast_incorp %>% 
  select(blast_OTU, substrate, incorporator) %>% 
  # Add up the blast hit incorporators for each substrate (rethink this through sometime to double check math)
  group_by(substrate) %>% # count number of incorporating taxa per substrate
  summarize(total=n()) %>% 
  ungroup() %>%
  ggplot(aes(x=reorder(substrate, -total), y=total)) +
  geom_col() +
  labs(title="ASV hits to incorporators", y="ASVs capable of incorporation", x="substrate") +
  theme_test()
```

#BOOKMARK
# Incorporation vs growth

Add growth metrics and genomic characteristics based on ASVs:

```{r}
meta <- 
growth <- readRDS("../data_intermediate/NIFA_grests_final_ind.rds")
pap <- readRDS("../data_intermediate/NIFA_paprica_ests.rds") %>% 
  select(ASV, n16S)

meta
growth
pap
blast_incorp
```

join dataframes

careful of multiple hits

g/lag/change vs substrate type
- differ between substrates? between insoluble/soluble? between soils?









# SCRAPS

## Label high latency incorporators

Latency refers to the length of time between the maximum respiration rate of a substrate and the day the OTU incorporated that substrate. If the OTU incorporated the substrate before the maximal respiration day, it likely directly metabolized the substrate. If the OTU incorporated the ubstrate far after the maximal respiration rate, the likelihood of secondary metabolism is greater (eating a microbe that died after it metabolizing the substrate) or the taxa was slow growing but directly metabolized the substrate.

Remove day 30 incorporators:

Max mineralization of all substrates occured far before day 30.

```{r}
# Label day 30 as latent
incorp_sig <- incorp_sig %>% 
  mutate(latent = if_else(day < 30, "no", "yes"))
```

Remove day 6 and 14 incorporators for xylose and amino acid:

Maximal respiration of these substrates occurred before day 6 in all ecosystems.

```{r}
# Label latent
incorp_sig <- incorp_sig %>% 
  mutate(latent = if_else(((substrate=="xylose" | substrate=="amino acid") & (day==6 | day==14)), "yes", latent))
```

