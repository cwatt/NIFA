---
title: "NIFA FullCyc2 incorporators workup"
author: "Cassandra Wattenburger"
date: "3/15/2023"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(results = "show")
knitr::opts_chunk$set(message = FALSE)
```

```{r}
# Clear working directory, load in packages, generate package info
rm(list=ls())

library("tidyverse")

sessionInfo()
```

# Import data

```{r}
# Incorporator data from DulLC
incorp <- readRDS("../cluster_fullcyc2/fullcyc2_l2fc_testoutput.rds")
incorp

# Taxonomy of incorporators
incorp_tax <- incorp %>% select(OTU, Phylum:Species)
```

# Reformat data

```{r}
# Reformat and exclude non-significant results
incorp_sig <- incorp %>% 
  mutate(ecosystem = gsub(".substrate == '12C-Con' & day == '[0-9]+' & ecosystem == '([a-z]+)'.+", "\\1", .id), # separate out .id column
         day = gsub(".substrate == '12C-Con' & day == '([0-9]+)' .+", "\\1", .id),
         day = as.numeric(day),
         substrate = gsub(".+substrate == '13C-([a-z]+)'.+", "\\1", .id, ignore.case=T),
         substrate = case_when(substrate=="Pal" ~ "palmitic acid",
                               substrate=="Ami" ~ "amino acid",
                               substrate=="Xyl" ~ "xylose",
                               substrate=="Cel" ~ "cellulose",
                               substrate=="Van" ~ "vanillin")) %>%
  select(OTU, ecosystem, day, substrate, log2FoldChange, padj) %>% 
  filter(padj < 0.05) # filter incorporators, Sam says deseq2 was set up so negative log2foldchange indicates incorporation
  
incorp_sig
```

Create list of incorporator OTUs:

```{r}
incorp_otus <- select(incorp_sig, OTU) %>% 
  unique()
```

```{r, eval=FALSE}
write_tsv(incorp_otus, "../mothur_cluster/incorp_otus.txt")
```

Create list of growing taxa from NIFA experiment:

```{r}
growth_asvs <- readRDS("../data_intermediate/NIFA_grests_final_ind.rds") %>% 
  select(ASV) %>% 
  unique()
```

```{r, eval=FALSE}
write_tsv(growth_asvs, "../mothur_cluster/growth_asvs.txt")
```

# BLAST processing

Import: 

```{r}
blast <- read_tsv("../blast_fullcyc2/nifa_fullcyc2_blastn_parsed.txt")
head(blast)
```

Choose best hit for each ASV (with at least 97% identity):

```{r}
# Select best hit(s)
blast_best <- filter(blast, Identity >= 97) %>% # remove hits lower than 97% identity
  group_by(Query) %>% 
  summarize(Identity = max(Identity)) %>% # choose highest identity match
  ungroup()

blast_best <- semi_join(blast, blast_best)
blast_best

# Tidy up
blast_best <- select(blast_best, ASV=Query, blast_OTU=Hit, blast_identity=Identity, blast_evalue=Evalue)
  
# Some summary
length(unique(blast_best$Query)) # ASVs matched with at least 97% identity
min(blast_best$Identity) # lowest identity match in queries
```

Identify ties:

```{r}
# Isolate ASVs with multiple highest hits
blast_dups_logic <- duplicated(blast_best$ASV)

blast_dups_asvs <- blast_best %>% 
  add_column(duplicated = blast_dups_logic) %>% 
  filter(duplicated==TRUE) %>% 
  select(ASV) %>% 
  unique() %>% 
  as.list()

# How many ASVs with duplicate equally best hits?
length(blast_dups_asvs$ASV)

# Isolate duplicate hits
blast_dups <- blast_best %>% 
  filter(ASV %in% blast_dups_asvs$ASV)

# Isolate single hits
blast_sing <- blast_best %>% 
  filter(!(ASV %in% blast_dups_asvs$ASV))
```

## Deal with multiple OTU hits

For ASVs with two or more OTU hits with equal percentage identity, I'll choose the lowest e-value. If e values also tie, I'll keep the OTU properties of both (or all) OTU hits.

https://www.ncbi.nlm.nih.gov/books/NBK62051/

```{r}
blast_dups_eval <- blast_dups %>% 
  group_by(ASV) %>% 
  summarize(blast_evalue = min(blast_evalue)) %>% # isolate lowest e-value hit
  ungroup()

# Filter by min. e-value
blast_dups <- blast_dups %>% 
  semi_join(blast_dups_eval)

# Remaining duplicates
blast_dups_logic2 <- duplicated(blast_dups$ASV)
blast_dups_asvs2 <- blast_dups %>% 
  add_column(duplicated = blast_dups_logic2) %>% 
  filter(duplicated==TRUE) %>% 
  select(ASV) %>% 
  unique() %>% 
  as.list()

blast_dups2 <- filter(blast_dups, ASV %in% blast_dups_asvs2$ASV)
blast_dups2
```

Look at taxonomy of duplicate OTU hits:

```{r}
# Isolate OTU hits from taxonomy info
tax_dups <- filter(incorp_tax, OTU %in% unique(blast_dups2$blast_OTU)) %>% 
  unique()

# Merge with blast results
blast_dups2 <- blast_dups2 %>% 
  left_join(tax_dups, by=join_by(blast_OTU==OTU))

blast_dups2
```

Visualize:

```{r}
# Phylum level
blast_dups2 %>% 
  ggplot(aes(x=Phylum, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Class
blast_dups2 %>% 
  ggplot(aes(x=Class, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Order
blast_dups2 %>% 
  ggplot(aes(x=Order, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Family
blast_dups2 %>% 
  ggplot(aes(x=Family, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Genus
blast_dups2 %>% 
  ggplot(aes(x=Genus, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())

# Species
blast_dups2 %>% 
  ggplot(aes(x=Species, y=blast_identity, color=ASV)) +
  geom_point(alpha=0.8) +
  facet_wrap(~ASV, scales = "free") +
  theme_test() +
  theme(legend.position = "none",
        axis.text.y = element_blank())
```

These plots tell me if the duplicate OTU hits fall in the same or different taxonomic groups. One dot per graph means they all are within the same group.

Duplicate OTU hits start diverging ~ order level, but the splits are among "uncultured", "ambigious", or "NA" groups which tells me these are uncultured and uncharacterized which would explain variation in higher resolution taxonomic placement. Overall taxa are very closely related, as expected. Likely OK to merge the substrate use qualities for the ASVs

Combine single and duplicate blast results:

```{r}
# Put single hits back in with duplicate hits
blast_mh <- bind_rows(blast_sing, blast_dups) %>% 
  mutate(multiple_hit=if_else(ASV %in% blast_dups_asvs2$ASV, "yes", "no")) # Add multiple hit warning column

blast_mh
```

# Simplify incorporation profiles

## Growth in ag vs meadow

If there is high similarity, I will collapse growth metrics between soils

```{r}
# Import growth data
growth <- readRDS("../data_intermediate/NIFA_grests_final_ind.rds")

# Paprica estimates
pap <- readRDS("../data_intermediate/NIFA_paprica_ests.rds")

# ASV averages
growth_asv <- growth %>% 
  inner_join(pap) %>% 
  mutate(start_abund_corr = start_abund/n16S,
         end_abund_corr = end_abund/n16S,
         change_abund_corr = change_abund/n16S) %>% 
  group_by(Soil, ASV) %>%
  summarize(g = mean(g),
            start_day = mean(start_day),
            end_day = mean(end_day),
            start_abund_corr = mean(start_abund),
            end_abund_corr = mean(end_abund),
            change_abund_corr = mean(change_abund_corr),
            n16S = mean(n16S)) %>% 
  ungroup()
```

Visualize:

```{r}
# g
growth_asv %>% 
  pivot_wider(c(ASV), names_from=Soil, values_from=g) %>% 
  filter(complete.cases(Ag) & complete.cases(Meadow)) %>% 
  ggplot(aes(x=Ag, y=Meadow)) +
  geom_point() +
  geom_abline(slope=1, linetype=2) +
  labs(x="Ag g", y="Meadow g") +
  theme_test()

# start day
growth_asv %>% 
  pivot_wider(c(ASV), names_from=Soil, values_from=start_day) %>% 
  filter(complete.cases(Ag) & complete.cases(Meadow)) %>% 
  ggplot(aes(x=Ag, y=Meadow)) +
  geom_point() +
  geom_abline(slope=1, linetype=2) +
  labs(x="Ag lag", y="Meadow lag") +
  theme_test()

# Start abund
growth_asv %>% 
  pivot_wider(c(ASV), names_from=Soil, values_from=start_abund_corr) %>% 
  filter(complete.cases(Ag) & complete.cases(Meadow)) %>% 
  ggplot(aes(x=Ag, y=Meadow)) +
  geom_point() +
  geom_abline(slope=1, linetype=2) +
  labs(x="Ag start abund", y="Meadow abund") +
  theme_test()

# end abund
growth_asv %>% 
  pivot_wider(c(ASV), names_from=Soil, values_from=end_abund_corr) %>% 
  filter(complete.cases(Ag) & complete.cases(Meadow)) %>% 
  ggplot(aes(x=Ag, y=Meadow)) +
  geom_point() +
  geom_abline(slope=1, linetype=2) +
  labs(x="Ag end abund", y="Meadow end abund") +
  theme_test()

# change abund
growth_asv %>% 
  pivot_wider(c(ASV), names_from=Soil, values_from=change_abund_corr) %>% 
  filter(complete.cases(Ag) & complete.cases(Meadow)) %>% 
  ggplot(aes(x=Ag, y=Meadow)) +
  geom_point() +
  geom_abline(slope=1, linetype=2) +
  labs(x="Ag change abund", y="Meadow change abund") +
  theme_test()
```

Definitely a lot of spread so I will keep growth metrics separated.

## Incorporation profile union

Create union of substrate incorporation properties among different ecosystems for the same OTU, was the OTU labelled and if so, what was the earliest day it was labelled in any ecosystem?

```{r}
# Simplify
incorp_simp <- data.frame()
for (o in unique(incorp_sig$OTU)) {
  for (s in unique(incorp_sig[incorp_sig$OTU==o,]$substrate)) {
    data_os <- filter(incorp_sig, OTU==o & substrate==s) # isolate substrates that were incorporated
    first_day <- min(data_os$day)
    this_row <- bind_cols(OTU=o, substrate=s, first_day=first_day)
    incorp_simp <- bind_rows(incorp_simp, this_row)
  }
}

incorp_simp
```

## Join with BLAST results

```{r}
blast_incorp <- full_join(incorp_simp, blast_mh, by=join_by(OTU==blast_OTU)) %>% 
  filter(!is.na(ASV)) %>% # remove incorporator OTUs that did not match an ASV
  rename(blast_OTU=OTU, incorp_firstday=first_day)

blast_incorp
```

## Simplify mutliple hits

Create union of incorporation profiles for OTUs that equally matched one ASV.

```{r}
# Parse
blast_incorp_simp <- data.frame()
for (a in unique(blast_incorp$ASV)) {
  data_a <- filter(blast_incorp, ASV==a) %>% 
    group_by(ASV, substrate, blast_identity, blast_evalue) %>% 
    summarize(incorp_firstday = min(incorp_firstday)) %>%  # isolate first day of incorporation among multiple hits (if any)
    ungroup() %>% 
    unique()
  blast_incorp_simp <- bind_rows(blast_incorp_simp, data_a)
}

# Visualize
blast_incorp_simp %>% 
  ggplot(aes(x=substrate, y=incorp_firstday)) +
  geom_jitter() +
  geom_hline(yintercept=c(3,6,14,30), linetype=2) +
  theme_test()
```

There is variation in first day of incorporation across substrates, so variable is worth keeping around.

# Summarize BLAST

BLAST % identity:

```{r}
mean(blast_incorp_simp$blast_identity)
median(blast_incorp_simp$blast_identity)
min(blast_incorp_simp$blast_identity)
max(blast_incorp_simp$blast_identity)
hist(blast_incorp_simp$blast_identity, main="Histogram", xlab="Percent identity to nearest BLAST hit")
```

BLAST e-values:

```{r}
mean(blast_incorp_simp$blast_evalue)
median(blast_incorp_simp$blast_evalue)
min(blast_incorp_simp$blast_evalue)
max(blast_incorp_simp$blast_evalue)
hist(blast_incorp_simp$blast_evalue, main="Histogram", xlab="Evalue of nearest BLAST hit")
```

Number of incorporation hits per substrate:

```{r}
# Summary table
blast_incorp_simp %>% 
  group_by(substrate) %>% 
  summarize(total = n())

# Visualize
blast_incorp_simp %>% 
  group_by(substrate) %>% 
  summarize(total = n()) %>% 
  ungroup() %>%
  ggplot(aes(x=reorder(substrate, -total), y=total)) +
  geom_col() +
  labs(title="ASV hits to incorporators", y="ASVs capable of incorporation", x="substrate") +
  theme_test()

blast_incorp_simp %>% 
  group_by(substrate, incorp_firstday) %>% 
  summarize(total = n()) %>% 
  ungroup() %>%
  ggplot(aes(x=reorder(substrate, -total), y=total)) +
  geom_col() +
  facet_wrap(~incorp_firstday) +
  labs(title="ASV hits to incorporators by day of earliest incorporation observed", y="ASVs capable of incorporation", x="substrate") +
  theme_test() +
  theme(axis.text.x=element_text(angle=45, hjust=1))
```

# Incorporation vs growth

Add growth metrics and genomic characteristics based on ASVs:

```{r}
# Paprica estimates
pap <- readRDS("../data_intermediate/NIFA_paprica_ests.rds") %>% 
  select(ASV, n16S)

# Growth estimates
growth_asv <- readRDS("../data_intermediate/NIFA_grests_final_ind.rds") %>% 
  mutate(length = end_day-start_day) %>% 
  select(ASV, Soil, Replicate, g, start_day, length, start_abund, end_abund, change_abund) %>% 
  left_join(pap) %>% 
  group_by(ASV, Soil) %>% 
  summarize(g = mean(g),
            start_day = mean(start_day),
            length = mean(length),
            start_abund_corr = mean(start_abund)/mean(n16S), 
            end_abund_corr = mean(end_abund)/mean(n16S),
            change_abund_corr = mean(change_abund)/mean(n16S),
            n16S = mean(n16S)) %>% 
  ungroup()

# Combine with incorporation profiles
growth_incorp <- growth_asv %>% 
  right_join(blast_incorp_simp)

growth_incorp
```

Visualize:

```{r}
# g
growth_incorp %>% 
  ggplot(aes(x=substrate, y=log(g), color=Soil)) +
  geom_violin() +
  geom_jitter(alpha=0.5) +
  theme_test()

# lag
growth_incorp %>% 
  ggplot(aes(x=substrate, y=start_day, color=Soil)) +
  geom_violin() +
  geom_jitter(alpha=0.5) +
  theme_test()

# Length
growth_incorp %>% 
  ggplot(aes(x=substrate, y=length, color=Soil)) +
  geom_violin() +
  geom_jitter(alpha=0.5) +
  theme_test()

# start abund
growth_incorp %>% 
  ggplot(aes(x=substrate, y=log(start_abund_corr), color=Soil)) +
  geom_violin() +
  geom_jitter(alpha=0.5) +
  theme_test()

# end abund
growth_incorp %>% 
  ggplot(aes(x=substrate, y=log(end_abund_corr), color=Soil)) +
  geom_violin() +
  geom_jitter(alpha=0.5) +
  theme_test()

# change abund corr
growth_incorp %>% 
  ggplot(aes(x=substrate, y=log(change_abund_corr), color=Soil)) +
  geom_violin() +
  geom_jitter(alpha=0.5) +
  theme_test()

# n16S
growth_incorp %>% 
  ggplot(aes(x=substrate, y=n16S, color=Soil)) +
  geom_violin() +
  geom_jitter(alpha=0.5) +
  theme_test()
```

# Clustering prepation

## Create features

```{r}
# Add features
# Number of substrates
substrate_num <- growth_incorp %>% 
  group_by(Soil, ASV) %>% 
  summarize(substrate_num = n())
# Add to df
growth_incorp <- growth_incorp %>% 
  left_join(substrate_num)

# Wide format
cluster_df <- growth_incorp %>% 
  select(Soil, ASV:n16S, substrate, incorp_firstday, substrate_num) %>% # remove blast stuff
  #mutate(incorp_firstday = as.character(incorp_firstday)) %>% # change to categorical
  pivot_wider(id_cols = c(Soil:n16S, substrate_num), names_from=substrate, values_from=incorp_firstday) %>% # wide format
  rename(palmitic_acid='palmitic acid', amino_acid='amino acid') 

# Separate variables for first incorporation day
incorp_firstday <- cluster_df %>% 
  select(cellulose:xylose) %>% 
  rename(cellulose_firstday=cellulose, amino_firstday=amino_acid, palmitic_firstday=palmitic_acid, 
         vanillin_firstday=vanillin, xylose_firstday=xylose) #%>% 
  #mutate_all(function(x) if_else(is.na(x), "NA", x))

# Put it all together
cluster_df <- cluster_df %>% 
  bind_cols(incorp_firstday) %>% 
  mutate(across(c(cellulose, amino_acid, palmitic_acid, vanillin, xylose), function(x) if_else(is.na(x), "no", "yes")), # binary yes/no incorporation
         label = paste0(Soil, "_", ASV)) %>% # unique observation labels for each soil and asv
  select(label, Soil, g:xylose_firstday)

cluster_df
```

## Check for correlations betwen continuous variables

I can remove ones that are highly correlated together (redundant).

```{r}
cor(cluster_df[, c('g', 'start_day', 'start_abund_corr', 'end_abund_corr', 'change_abund_corr', 'n16S', 'substrate_num')])
```

Start, end, and change abund are all highly correlated. I'll keep change abund only.

Remove start and end abundance features:

```{r}
cluster_df <- cluster_df %>% 
  select(everything(), -c(start_abund_corr, end_abund_corr))

cluster_df
```

## Continuous var. distributions

This algorithm doesn't do well with data that is heavy-tailed.

```{r}
# g
cluster_df %>% 
  ggplot(aes(x=log(g))) +
  geom_density() +
  theme_test()

# lag
cluster_df %>% 
  ggplot(aes(x=log(start_day+1))) +
  geom_density() +
  theme_test()

# length
cluster_df %>% 
  ggplot(aes(x=log(length))) +
  geom_density() +
  theme_test()

# Change abund
cluster_df %>% 
  ggplot(aes(x=log(change_abund_corr))) +
  geom_density() +
  theme_test()

# n16S
cluster_df %>% 
  ggplot(aes(x=log(n16S))) +
  geom_density() +
  theme_test()

# substrate number
cluster_df %>% 
  ggplot(aes(x=substrate_num)) +
  geom_density() +
  theme_test()
```

Most continuous variables need log transform to be normal. Would need to remove n16S and susbtrate number for Kamila because violate normality.

```{r}
cluster_df2 <- cluster_df %>% 
  mutate(g = log(g),
         start_day = log(start_day+1),
         length = log(length),
         change_abund_corr = abs(log(change_abund_corr))) %>% 
  select(everything(), -n16S, -substrate_num)

cluster_df2
```

## Principle components

Continuous variables only

```{r}
# Continuous features only
cluster_cont_pc <- cluster_df2 %>% 
  select(label:change_abund_corr, -Soil) %>% 
  column_to_rownames(var="label") %>% 
  prcomp(scale = TRUE) # principle components, scaled

# Summary
cluster_cont_pc
summary(cluster_cont_pc)
```

Visualize:

```{r}
# Add back soil
label_soil <- select(cluster_df2, label, Soil)

cluster_pc <- cluster_cont_pc$x %>%
  data.frame() %>% 
  rownames_to_column(var= "label") %>% 
  inner_join(label_soil) 

# 2D
cluster_pc %>% 
  ggplot(aes(x=PC1, y=PC2, color=Soil)) +
  geom_point() +
  theme_test()

# 3D
library(plotly)
plot_ly(cluster_pc, x=~PC1, y=~PC2, z=~PC3, color=~Soil)
```

Length & g, change abund & start_day dominate the first and second principle components. Start day dominates the third. I know the outliers are due to either n16S or substrate number because disappear when those variables are removed from principle components.

## Feature selection

For Kamila:

```{r}
# Features, removing n16S, number substrates (not normal), and first day of incorporation for now
clusterkmla_feats <- cluster_df2 %>% 
  select(label, g:change_abund_corr, cellulose:xylose)

clusterkmla_feats
```

# Kamila clustering

Decided to use Kamila for mixed datasets: https://rdrr.io/cran/kamila/f/README.md

```{r}
library(kamila)
```

## Format data

```{r}
clusterkmla_feats

# Continuous variables
cont_feats <- clusterkmla_feats %>%
  column_to_rownames(var="label") %>% 
  select(g:change_abund_corr)
cont_feats

# Categorical variables
cat_feats <- clusterkmla_feats %>% 
  column_to_rownames(var="label") %>%
  select(cellulose:xylose) %>% 
  mutate(cellulose = as_factor(cellulose),
         cellulose = fct_relevel(cellulose, "yes", "no"),
         amino_acid = as_factor(amino_acid),
         amino_acid = fct_relevel(amino_acid, "yes", "no"),
         palmitic_acid = as_factor(palmitic_acid),
         palmitic_acid = fct_relevel(palmitic_acid, "yes", "no"),
         vanillin = as_factor(vanillin),
         vanillin = fct_relevel(vanillin, "yes", "no"),
         xylose = as_factor(xylose),
         xylose = fct_relevel(xylose, "yes", "no"),)
cat_feats
```

## Scale continuous variables

```{r}
cont_scale <- cont_feats %>% 
  mutate(g = scale(g),
         start_day = scale(start_day),
         length = scale(length),
         change_abund_corr = scale(change_abund_corr))
```

## Cluster

The data is a continuous cloud, so the cluster number is only important in that it helps explain the variation at the extreme ends of that cloud to help differentiate growth strategies within a continuum. I'll try comparing 2-5 clusters, because any more than 5 clusters would be difficult to interpret ecologically, I think.

```{r}
set.seed(11)

# Clustering
kam2 <- kamila(cont_scale, cat_feats, numClust=2, numInit=10)
kam3 <- kamila(cont_scale, cat_feats, numClust=3, numInit=10)
kam4 <- kamila(cont_scale, cat_feats, numClust=4, numInit=10)
kam5 <- kamila(cont_scale, cat_feats, numClust=5, numInit=10)

# Psuedologlikelihoods
kam2$finalLogLik
kam3$finalLogLik
kam4$finalLogLik
kam5$finalLogLik
```

Psuedo log likelihood decreases with increasing cluster numbers, so less clusters the better. Principle components of continuous variables showed that first three PCs explained 95% of variability, so I will go with three clusters.

Create dataframe with cluster memberships:

```{r}
# Create dataframe
soil_meta <- cluster_df2 %>% select(label, Soil)

# Cluster input data
kam3_df <- data.frame(kam3$input$conVar, kam3$input$catFactor, cluster=kam3$finalMemb) %>% 
  rownames_to_column(var="label") %>% 
  inner_join(soil_meta)
kam3_df

# Original untransformed, unscaled data
kam3_df2 <- kam3_df %>% 
  select(label, Soil, cluster) %>% 
  inner_join(cluster_df)
kam3_df2
```

# Cluster exploration

## Continuous variables

Visualize:

```{r}
# Continuous variables
# g
kam3_df2 %>% 
  ggplot(aes(x=cluster, y=log(g), color=Soil)) +
  geom_boxplot(aes(group=cluster)) +
  geom_jitter() +
  theme_test()

# start day
kam3_df2 %>% 
  ggplot(aes(x=cluster, y=log(start_day+1), color=Soil)) +
  geom_boxplot(aes(group=cluster)) +
  geom_jitter() +
  theme_test()

# length
kam3_df2 %>% 
  ggplot(aes(x=cluster, y=log(length), color=Soil)) +
  geom_boxplot(aes(group=cluster)) +
  geom_jitter() +
  theme_test()

# change abund
kam3_df2 %>% 
  ggplot(aes(x=cluster, y=log(change_abund_corr), color=Soil)) +
  geom_boxplot(aes(group=cluster)) +
  geom_jitter() +
  theme_test()

# n16S
kam3_df2 %>% 
  ggplot(aes(x=cluster, y=log(n16S), color=Soil)) +
  geom_boxplot(aes(group=cluster)) +
  geom_jitter() +
  theme_test()

# substrate number
kam3_df2 %>% 
  ggplot(aes(x=cluster, y=substrate_num, color=Soil)) +
  geom_boxplot(aes(group=cluster)) +
  geom_jitter() +
  theme_test()
```

### Statistics

Summary:

```{r}
# mean and standard dev.
kam3_df2 %>%
  group_by(cluster, Soil) %>%
  summarize(g_mean = mean(g),
            g_sd = sd(g),
            start_mean = mean(start_day),
            start_sd = sd(start_day),
            length_mean = mean(length),
            length_sd = sd(length),
            chabund_mean = mean(change_abund_corr),
            chabund_sd = sd(change_abund_corr),
            n16S_mean = mean(n16S),
            n16S_sd = sd(n16S),
            sub_mean = mean(substrate_num),
            sub_sd = mean(substrate_num))
```

Generation time:

```{r}
# Overall
gclust_lm <- lm(log(g) ~ cluster + Soil + cluster*Soil, data=kam3_df2)
hist(resid(gclust_lm)) # normal
plot(predict(gclust_lm), resid(gclust_lm)) # good enough
summary(gclust_lm)

# Contrasts
# cluster 1 vs 2
gclust12_lm <- lm(log(g) ~ cluster, data=filter(kam3_df2, cluster %in% c(1,2)))
hist(resid(gclust12_lm))
plot(predict(gclust12_lm), resid(gclust12_lm))
summary(gclust12_lm)
# cluster 1 vs 3
gclust13_lm <- lm(log(g) ~ cluster, data=filter(kam3_df2, cluster %in% c(1,3)))
hist(resid(gclust13_lm))
plot(predict(gclust13_lm), resid(gclust13_lm))
summary(gclust13_lm)
# cluster 2 vs 3
gclust23_lm <- lm(log(g) ~ cluster, data=filter(kam3_df2, cluster %in% c(2,3)))
hist(resid(gclust23_lm))
plot(predict(gclust23_lm), resid(gclust23_lm))
summary(gclust23_lm)
# multiple test correction
p.adjust(p=c(summary(gclust12_lm)$coefficients[2,4], summary(gclust13_lm)$coefficients[2,4], summary(gclust23_lm)$coefficients[2,4]),
         method="holm", n=3)
```

Start day:

```{r}
# Overall
startclust_lm <- lm(log(start_day+1) ~ cluster + Soil + cluster*Soil, data=kam3_df2)
hist(resid(startclust_lm)) # normal
plot(predict(startclust_lm), resid(startclust_lm)) # good enough
summary(startclust_lm)
```

Length of growth:

```{r}
# Overall
lengthclust_lm <- lm(log(length) ~ cluster + Soil + cluster*Soil, data=kam3_df2)
hist(resid(lengthclust_lm)) # normal
plot(predict(lengthclust_lm), resid(lengthclust_lm)) # good enough
summary(lengthclust_lm)

# Contrasts
# cluster 1 vs 2
lengthclust12_lm <- lm(log(length) ~ cluster, data=filter(kam3_df2, cluster %in% c(1,2)))
hist(resid(lengthclust12_lm))
plot(predict(lengthclust12_lm), resid(lengthclust12_lm))
summary(lengthclust12_lm)
# cluster 1 vs 3
lengthclust13_lm <- lm(log(length) ~ cluster, data=filter(kam3_df2, cluster %in% c(1,3)))
hist(resid(lengthclust13_lm))
plot(predict(lengthclust13_lm), resid(lengthclust13_lm))
summary(lengthclust13_lm)
# cluster 2 vs 3
lengthclust23_lm <- lm(log(length) ~ cluster, data=filter(kam3_df2, cluster %in% c(2,3)))
hist(resid(lengthclust23_lm))
plot(predict(lengthclust23_lm), resid(lengthclust23_lm))
summary(lengthclust23_lm)
# multiple test correction
p.adjust(p=c(summary(lengthclust12_lm)$coefficients[2,4], summary(lengthclust13_lm)$coefficients[2,4], 
             summary(lengthclust23_lm)$coefficients[2,4]), method="holm", n=3)
```

Change abundance:

```{r}
# Overall
chabundclust_lm <- lm(log(change_abund_corr) ~ cluster + Soil + cluster*Soil, data=kam3_df2)
hist(resid(chabundclust_lm)) # normal
plot(predict(chabundclust_lm), resid(chabundclust_lm)) # good enough
summary(chabundclust_lm)

# Contrasts
# cluster 1 ag vs meadow
chabund1_lm <- lm(log(change_abund_corr) ~ Soil, data=filter(kam3_df2, cluster==1))
hist(resid(chabund1_lm))
plot(predict(chabund1_lm), resid(chabund1_lm))
summary(chabund1_lm)
# cluster 2 ag vs meadow
chabund2_lm <- lm(log(change_abund_corr) ~ Soil, data=filter(kam3_df2, cluster==2))
hist(resid(chabund2_lm))
plot(predict(chabund2_lm), resid(chabund2_lm))
summary(chabund2_lm)
# cluster 3 ag vs meadow
chabund3_lm <- lm(log(change_abund_corr) ~ Soil, data=filter(kam3_df2, cluster==3))
hist(resid(chabund3_lm))
plot(predict(chabund3_lm), resid(chabund3_lm))
summary(chabund3_lm)

# cluster 1 vs 2
chabund12_lm <- lm(log(change_abund_corr) ~ cluster, data=filter(kam3_df2, cluster %in% c(1,2)))
hist(resid(chabund12_lm))
plot(predict(chabund12_lm), resid(chabund12_lm))
summary(chabund12_lm)
# cluster 1 vs 3
chabund13_lm <- lm(log(change_abund_corr) ~ cluster, data=filter(kam3_df2, cluster %in% c(1,3)))
hist(resid(chabund13_lm))
plot(predict(chabund13_lm), resid(chabund13_lm))
summary(chabund13_lm)
# cluster 2 vs 3
chabund23_lm <- lm(log(change_abund_corr) ~ cluster, data=filter(kam3_df2, cluster %in% c(2,3)))
hist(resid(chabund23_lm))
plot(predict(chabund23_lm), resid(chabund23_lm))
summary(chabund23_lm)

# multiple test correction
p.adjust(p=c(summary(chabund1_lm)$coefficients[2,4], summary(chabund2_lm)$coefficients[2,4], summary(chabund3_lm)$coefficients[2,4],
             summary(chabund12_lm)$coefficients[2,4], summary(chabund13_lm)$coefficients[2,4], summary(chabund23_lm)$coefficients[2,4]),
         method="holm", n=6)
```

n16S:

```{r}
# Overall
n16Sclust_lm <- lm(log(n16S) ~ cluster + Soil + cluster*Soil, data=kam3_df2)
hist(resid(n16Sclust_lm)) # non-normal
plot(predict(n16Sclust_lm), resid(n16Sclust_lm)) # heteroskedastic
# Switch to welch's t tests
# Contrasts
n16Ssoil_welch <- t.test(n16S ~ Soil, data=kam3_df2, var.equal=FALSE)
n16S12_welch <- t.test(n16S ~ cluster, data=filter(kam3_df2, cluster %in% c(1,2)), var.equal=FALSE)
n16S13_welch <- t.test(n16S ~ cluster, data=filter(kam3_df2, cluster %in% c(1,3)), var.equal=FALSE)
n16S23_welch <- t.test(n16S ~ cluster, data=filter(kam3_df2, cluster %in% c(2,3)), var.equal=FALSE)
# P adjustment
p.adjust(p=c(n16Ssoil_welch$p.value, n16S12_welch$p.value, n16S13_welch$p.value, n16S23_welch$p.value), 
         method="holm", n=4)
```

Number of substrates:

```{r}
# Overall
subclust_lm <- lm(log(substrate_num) ~ cluster + Soil + cluster*Soil, data=kam3_df2)
hist(resid(subclust_lm)) # not normal
plot(predict(subclust_lm), resid(subclust_lm)) # homoskedastic
# Switch to non-parametric kruskal wallis
kruskal.test(substrate_num ~ cluster, data=kam3_df2)
kruskal.test(substrate_num ~ Soil, data=kam3_df2)

# Contrasts
subclust12_kw <- kruskal.test(substrate_num ~ cluster, data=filter(kam3_df2, cluster %in% c(1,2)))
subclust13_kw <- kruskal.test(substrate_num ~ cluster, data=filter(kam3_df2, cluster %in% c(1,3)))
subclust23_kw <- kruskal.test(substrate_num ~ cluster, data=filter(kam3_df2, cluster %in% c(2,3)))
# P adjustment
p.adjust(p=c(subclust12_kw$p.value, subclust13_kw$p.value, subclust23_kw$p.value), method="holm", n=3)
```

## Labelling profiles

```{r}
# Totals substrate*cluster
subclust_totals <- kam3_df2 %>% 
  pivot_longer(cols=cellulose:xylose, names_to="substrate", values_to="labelled") %>% 
  group_by(cluster, substrate) %>% 
  summarize(total=n())

subclust_totals

# Calculate poportions by cluster and substrate
subclust_prop <- kam3_df2 %>% 
  pivot_longer(cols=cellulose:xylose, names_to="substrate", values_to="labelled") %>% 
  group_by(cluster, substrate, labelled) %>% 
  summarize(count=n()) %>% 
  inner_join(subclust_totals) %>% 
  mutate(prop = count/total)

subclust_prop
```

Visualize:

```{r}
# Raw
subclust_prop %>% 
  filter(labelled=="yes") %>% 
  mutate(cluster=as.character(cluster)) %>% 
  ggplot(aes(x=substrate, y=count, color=cluster)) +
  geom_point() +
  labs(y="Number labelled") +
  theme_test()

# Proportions
subclust_prop %>% 
  filter(labelled=="yes") %>% 
  mutate(cluster=as.character(cluster)) %>% 
  ggplot(aes(x=substrate, y=prop, color=cluster)) +
  geom_point() +
  labs(y="Proportion labelled") +
  theme_test()
```

Statistics: Fisher's exact test

```{r}
# Reformat
# Each column should be a cluster, each row a substrate, "yes" counts
clustsub_mx <- subclust_prop %>% 
  filter(labelled=="yes") %>% 
  select(cluster, substrate, count) %>% 
  pivot_wider(names_from=cluster, values_from=count) %>% 
  column_to_rownames(var="substrate") %>% 
  as.matrix

clustsub_mx

# Fisher exact tests
# Contrasts
fish12 <- fisher.test(clustsub_mx[,1:2], simulate.p.value = TRUE, B = 1e6) # cluster 1 vs 2
fish13 <- fisher.test(clustsub_mx[,c(1,3)], simulate.p.value = TRUE, B = 1e6) # cluster 1 vs 3
fish23 <- fisher.test(clustsub_mx[,2:3], simulate.p.value = TRUE, B = 1e6) # cluster 2 vs 3
# Multiple test adjustment
p.adjust(p=c(fish12$p.value, fish13$p.value, fish23$p.value), method="holm", n=3)
```

## Clusters on top of principle components

```{r}
# 3D
plot_ly(inner_join(cluster_pc, kam3_df), x=~PC1, y=~PC2, z=~PC3, color=~cluster)
```

Export cluster memberships and data for continued analyses:

```{r, eval=FALSE}
# Cluster membership
clust <- kam3_df2 %>%
  mutate(ASV = gsub("Ag_|Meadow_(.+)", "\\1", label)) %>% 
  select(ASV, Soil, cluster) 
clust

# Incorporation profiles
incorp <- kam3_df2 %>% 
  mutate(ASV = gsub("Ag_|Meadow_(.+)", "\\1", label)) %>% 
  select(ASV, Soil, cellulose:xylose_firstday, substrate_num)
incorp  

# Save
saveRDS(clust, file="../data_intermediate/NIFA_clusters.rds")
saveRDS(incorp, file="../data_intermediate/NIFA_incorp_profiles.rds")
```

